---
title: "arg2"
---
```{r setup, include=FALSE}
library(tidyverse)
```

```{r}
simulation <- function() {
  disable_invalid_actions <- function() {
    ## initialize action space
    actions <- tribble(
      ~new, ~qA, ~qB, ~assA, ~assB,
      1, 1, 1, 1, 1
    )
    if (enforce_new_as_next_action) {
      return(tribble(
        ~new, ~qA, ~qB, ~assA, ~assB,
        1, 0, 0, 0, 0
      ))
    }
    if (isTRUE(all_equal(state$card, c('x', 'x')))) {
      actions$new <- 0
    }
    if ((state %>% filter(feature == 'A') %>% .$card) != 'x') {
      actions$qA <- 0
    }
    if ((state %>% filter(feature == 'B') %>% .$card) != 'x') {
      actions$qB <- 0
    }
    temp <- state %>% filter(feature == 'A') %>% select(slot, card)
    if (temp$slot == 'full' || temp$card == 'x') {
      actions$assA <- 0
    }
    temp <- state %>% filter(feature == 'B') %>% select(slot, card)
    if (temp$slot == 'full' || temp$card == 'x') {
      actions$assB <- 0
    }
    return(actions)
  }
  
  agent_choose_action <- function(strategy) {
    if (strategy == 'random') {
      sample(colnames(actions), 1, prob = unlist(actions)) %>% as.character
    }
  }
  
  game_update_state <- function(chosen_action) {
    ## this function works with side effects / global assignments / <<-
    if (chosen_action == 'new') {
      ## sample next card
      card <<- population %>% filter(card == card_sequence[card_sequence_index])
      card_sequence_index <<- card_sequence_index + 1
      ## reset state
      state[state$feature == 'A',]$card <<- 'x'
      state[state$feature == 'B',]$card <<- 'x'
    } else if (chosen_action == 'qA') {
      state[state$feature == 'A',]$card <<- card[card$feature == 'A',]$value
    } else if (chosen_action == 'qB') {
      state[state$feature == 'B',]$card <<- card[card$feature == 'B',]$value
    } else if (chosen_action == 'assA') {
      state[state$feature == 'A',]$slot <<- 'full'
    } else if (chosen_action == 'assB') {
      state[state$feature == 'B',]$slot <<- 'full'
    }
  }
  
  update_history <- function() {
    history_row <- bind_cols(
      i = i, 
      state %>% pivot_wider(names_from = feature, values_from = c(slot, card)), 
      actions,
      chosen_action = chosen_action, 
      card %>% pivot_wider(names_from = feature, values_from = value))
    history <<- bind_rows(history, history_row)
  }
  
  RARE_FEATURE <- 'A'
  
  state <- tribble(
    ~rare, ~feature, ~slot, ~card,
    RARE_FEATURE, 'A', '[ ]', 'x',
    RARE_FEATURE, 'B', '[ ]', 'x'
  )
  
  population <- tribble(
      ~card, ~feature, ~value,
      1,  'A', "long",
      1,  'B', "long",
      2,  'A', "long",
      2,  'B', "short",
      3,  'A', "short",
      3,  'B', "long",
      4,  'A', "short",
      4,  'B', "long",
      5,  'A', "short",
      5,  'B', "long",
      6,  'A', "short",
      6,  'B', "long",
      7,  'A', "short",
      7,  'B', "short",
      8,  'A', "short",
      8,  'B', "short",
      9,  'A', "short",
      9,  'B', "short",
      10,  'A', "short",
      10,  'B', "short"
  )
  
  set.seed(123)
  card_sequence <- sample(1:max(population$card))
  card_sequence_index <- 1
  
  ## initialize game
  history <- list()
  enforce_new_as_next_action <- TRUE
  
  ## play game
  for (i in 1:100) {
    actions <- disable_invalid_actions()
    chosen_action <- agent_choose_action(strategy = 'random')
    game_update_state(chosen_action)
    
    update_history()
    
    enforce_new_as_next_action <- chosen_action %in% c('assA', 'assB')
    
    if ((card_sequence_index > length(card_sequence)) || (isTRUE(all_equal(state$slot, c('full', 'full'))))) {
      break  ## game over
    }
  }
  history
}
```

```{r}
history <- simulation()
history
```
